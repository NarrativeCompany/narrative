package org.narrative.network.customizations.narrative.channels;

import org.narrative.common.persistence.DAOObject;
import org.narrative.common.persistence.OID;
import org.narrative.common.persistence.ObjectPair;
import org.narrative.common.persistence.hibernate.HibernateEnumSetType;
import org.narrative.common.persistence.hibernate.HibernateInstantType;
import org.narrative.common.persistence.hibernate.IntegerEnumType;
import org.narrative.network.core.cluster.partition.PartitionGroup;
import org.narrative.network.core.user.User;
import org.narrative.network.customizations.narrative.channels.dao.ChannelDAO;
import org.narrative.network.customizations.narrative.invoices.Invoice;
import org.narrative.network.customizations.narrative.niches.niche.Niche;
import org.narrative.network.customizations.narrative.personaljournal.PersonalJournal;
import org.narrative.network.customizations.narrative.posts.ChannelContent;
import org.narrative.network.customizations.narrative.publications.Publication;
import org.narrative.network.shared.daobase.NetworkDAOImpl;
import lombok.Getter;
import lombok.Setter;
import lombok.experimental.FieldNameConstants;
import org.hibernate.annotations.Cache;
import org.hibernate.annotations.CacheConcurrencyStrategy;
import org.hibernate.annotations.Cascade;
import org.hibernate.annotations.ForeignKey;
import org.hibernate.annotations.Proxy;
import org.hibernate.annotations.Type;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.validation.constraints.NotNull;

import java.time.Instant;
import java.util.Collections;
import java.util.EnumSet;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.function.Function;

import static org.narrative.common.util.CoreUtils.*;
import static org.narrative.network.shared.util.NetworkCoreUtils.*;

/**
 * Date: 2018-12-19
 * Time: 10:40
 *
 * @author jonmark
 */
@Getter
@Setter
@Entity
@Proxy
@FieldNameConstants
@Cache(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)
public class Channel implements DAOObject<ChannelDAO> {
    private static final String HAS_JIT_INITED_FOLLOWED_USER_PROPERTY = Channel.class.getName() + "-HasJITInitedFollowedUser";

    // jw: because this oid can correspond to one of several objects (PersonalJournal, Niche, etc) we cannot annotate it
    //     as generated by a different field. The constructor has to assign it from the associated object that it represents.
    //     The downside of this is that we have to store the root object before we can assign this value, which also means
    //     that for places where this hangs we cannot require the association from the parent, and must annotate it as optional.
    //     Meaning, there can be no foreign key association ensuring that this exists from Niche -> Channel, for example.
    @Id
    private OID oid;

    @NotNull
    @Type(type = IntegerEnumType.TYPE)
    private ChannelType type;

    @OneToMany(fetch = FetchType.LAZY, mappedBy = FollowedChannel.FIELD__CHANNEL__NAME, cascade = CascadeType.ALL)
    private List<FollowedChannel> followers;

    @OneToMany(fetch = FetchType.LAZY, mappedBy = ChannelContent.FIELD__CHANNEL, cascade = CascadeType.ALL)
    private List<ChannelContent> contents;

    @ManyToOne(fetch = FetchType.LAZY)
    @ForeignKey(name = "fk_channel_purchaseInvoice")
    private Invoice purchaseInvoice;

    @ManyToOne()
    @Cascade({org.hibernate.annotations.CascadeType.PERSIST, org.hibernate.annotations.CascadeType.MERGE, org.hibernate.annotations.CascadeType.REMOVE, org.hibernate.annotations.CascadeType.DELETE, org.hibernate.annotations.CascadeType.SAVE_UPDATE, org.hibernate.annotations.CascadeType.REPLICATE, org.hibernate.annotations.CascadeType.DELETE_ORPHAN, org.hibernate.annotations.CascadeType.LOCK, org.hibernate.annotations.CascadeType.EVICT})
    @ForeignKey(name = "fk_channel_primaryDomain")
    private ChannelDomain primaryDomain;

    private transient Boolean followedByCurrentUser;

    private transient Map<? extends ChannelRole, Integer> userCountsByRole;
    private transient Map<? extends ChannelRole, List<User>> usersByRole;
    private transient Map<? extends ChannelRole, List<User>> invitedUsersByRole;

    // jw: this column is used to prevent TribunalIssueTypes that affect the status of the channelConsumer from being created for a specific period of time.
    @Type(type = HibernateInstantType.TYPE)
    private Instant statusRelatedTribunalIssuesLockedUntilDatetime;

    /**
     * @deprecated for hibernate use only
     */
    public Channel() {}

    public Channel(ChannelConsumer consumer) {
        this.oid = consumer.getOid();
        this.type = consumer.getChannelType();
    }

    public Niche getNiche() {
        if (getType().isNiche()) {
            return Niche.dao().get(getOid());
        }
        return null;
    }

    public Publication getPublication() {
        if (getType().isPublication()) {
            return Publication.dao().get(getOid());
        }
        return null;
    }

    public PersonalJournal getPersonalJournal() {
        if (getType().isPersonalJournal()) {
            return PersonalJournal.dao().get(getOid());
        }
        return null;
    }

    public List<FollowedChannel> getFollowers() {
        return followers;
    }

    public void setFollowers(List<FollowedChannel> followers) {
        this.followers = followers;
    }

    public Boolean getFollowedByCurrentUser() {
        // never need to initialize a value here for guests
        if (!networkContext().getPrimaryRole().isRegisteredUser()) {
            return null;
        }
        // bl: load this just-in-time since we always must return the correct value due to the way apollo caching works
        if (followedByCurrentUser == null) {
            // bl: track how many times we have calculated this in the session. if it's ever more than 1,
            // throw an error since we should always populate in bulk via FollowedChannelDAO.populateChannelConsumersFollowedByCurrentUserField.
            PartitionGroup.getCurrentPartitionGroup().performSingleInstanceJitSafetyChecks(HAS_JIT_INITED_FOLLOWED_USER_PROPERTY);

            // jw: since we got here we know we are clear to setup the cached value
            FollowedChannel.dao().populateChannelsFollowedByCurrentUserField(networkContext().getUser(), Collections.singleton(this));
            assert followedByCurrentUser != null : "Should always have initialized followedByCurrentUser at this point!";
        }
        return followedByCurrentUser;
    }

    public void setFollowedByCurrentUser(Boolean followedByCurrentUser) {
        assert networkContext().getPrimaryRole().isRegisteredUser() : "Should only ever set followedByCurrentUser for registered users!";
        this.followedByCurrentUser = followedByCurrentUser;
    }

    public <T extends ChannelConsumer> T getConsumer() {
        return getType().getConsumer(this);
    }

    public Invoice refundPurchaseInvoice() {
        assert exists(getPurchaseInvoice()) : "The purchase invoice should always be set when calling this method!";

        Invoice invoice = getPurchaseInvoice();
        invoice.refund();
        setPurchaseInvoice(null);

        return invoice;
    }

    public boolean isCanAppealStatus() {
        if (!getType().isSupportsStatusAppeals()) {
            return false;
        }

        // jw: you can only repeal if there is no lock time, or the lock has passed.
        return getStatusRelatedTribunalIssuesLockedUntilDatetime() == null || getStatusRelatedTribunalIssuesLockedUntilDatetime().isBefore(Instant.now());
    }

    public <R extends Enum<R> & ChannelRole> Map<R, Integer> getUserCountsByRole() {
        if (userCountsByRole == null) {
            Map<R, Integer> counts = new HashMap<>();

            // jw: let's prime the counts for all roles:
            for (R role : (R[]) getType().getRoleType().getEnumConstants()) {
                counts.put(role, 0);
            }

           for (ObjectPair<Long, Number>  rolesAndCount : ChannelUser.dao().getUserCountByRoles(this)) {
               int count = rolesAndCount.getTwo().intValue();
               EnumSet<R> roles = HibernateEnumSetType.parseEnumSet(getType().getRoleType(), rolesAndCount.getOne());

               for (R role : roles) {
                   // jw: despite the warning here, val will always exist thanks to the code above
                   counts.compute(role, (key, val) -> val + count);
               }
            }

            userCountsByRole = Collections.unmodifiableMap(counts);
        }

        return (Map<R, Integer>) userCountsByRole;
    }

    public <R extends Enum<R> & ChannelRole> Map<R, List<User>> getUsersByRole() {
        if (usersByRole == null) {
            usersByRole = ChannelUser.dao().getChannelRoleToUsers(this, (Function<ChannelUser, Set<R>>)ChannelUser::getRolesResolved);
        }

        return (Map<R, List<User>>) usersByRole;
    }

    public <R extends Enum<R> & ChannelRole> Map<R, List<User>> getInvitedUsersByRole() {
        if (invitedUsersByRole == null) {
            invitedUsersByRole = ChannelUser.dao().getChannelRoleToUsers(this, (Function<ChannelUser, Set<R>>)ChannelUser::getInvitedRolesResolved);
        }

        return (Map<R, List<User>>) invitedUsersByRole;
    }

    public static ChannelDAO dao() {
        return NetworkDAOImpl.getDAO(Channel.class);
    }
}
